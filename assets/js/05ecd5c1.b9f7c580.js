"use strict";(globalThis.webpackChunkglados_documentation=globalThis.webpackChunkglados_documentation||[]).push([[663],{5323:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Optimisation","title":"Optimisation","description":"Bitset","source":"@site/docs/Optimisation.md","sourceDirName":".","slug":"/Optimisation","permalink":"/gomoku/docs/Optimisation","draft":false,"unlisted":false,"editUrl":"https://github.com/yanisdolivet/gomoku/tree/main/documentation/docs/Optimisation.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"Optimisation","title":"Optimisation","sidebar_position":2}}');var n=i(4848),s=i(8453);const a={id:"Optimisation",title:"Optimisation",sidebar_position:2},r="Optimisation",c={},l=[{value:"Bitset",id:"bitset",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2}];function h(e){const t={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"optimisation",children:"Optimisation"})}),"\n",(0,n.jsx)(t.h2,{id:"bitset",children:"Bitset"}),"\n",(0,n.jsx)(t.p,{children:"To optimise the project, we use bitset to store the board state and avoid using vectors or 2D arrays.\nThe reason is that vectors and 2D arrays are not optimised for the minimax algorithm and can lead to performance issues.\nA bitset uses only 1 bit per position, whereas a vector or 2D array of int uses 32 bits (4 bytes) per position. This makes a bitset 32 times more space-efficient, which is why we use it in the Board class."}),"\n",(0,n.jsx)(t.h2,{id:"bitwise-operations",children:"Bitwise operations"}),"\n",(0,n.jsx)(t.p,{children:"To optimise the project, we use bitwise operations to check for a winner. We need to optimise this function because it is call by the Monte Carlo Tree Search algorithm. Monte Carlo Tree Search search for the best move by simulating multiple games. If checkWin take only 10ms to check the winner, the Monte Carlo Tree Search can simule 1 000 000 games in 1 second. If checkWin take 1 millisecond to check the winner, the Monte Carlo Tree Search can simule 1 000 games in 1 second.\nBitwise operations are faster than using loops to check for a winner because they are executed at the hardware level.\nTo explain it simply, bitwise operations are executed at the hardware level, while loops are executed at the software level. To check winner with loop, we need to check each bit of the board, while with bitwise operations, we can check multiple bits at once. At the final, bitwise check 64 bits (because processor is 64 bits) in 1 operation, while loop check 1 bit in 1 operation. The processor execute only 7 operations to check for a winner with bitwise.\nBitwise is the ultimate optimisation for this project for 3 reasons:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"No loop on runtime, all the loop are implemented in the hardware level"}),"\n",(0,n.jsx)(t.li,{children:"Register parallelism, the processor can execute multiple operations at once"}),"\n",(0,n.jsx)(t.li,{children:"Branchless, no if condition to check for a winner. This condition is not optimised by the processor. The instruction flux is linear, this is perfect for the processor.\nTo add more optimisation on the bitwise operations, we use inline function. That reduce the function call overhead and improve the performance. In a optimised code function call makes loose many performance. That would be shameful for a project like this."}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var o=i(6540);const n={},s=o.createContext(n);function a(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);