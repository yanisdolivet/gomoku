"use strict";(globalThis.webpackChunkglados_documentation=globalThis.webpackChunkglados_documentation||[]).push([[663],{5323:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Optimisation","title":"Optimisation","description":"Bitset","source":"@site/docs/Optimisation.md","sourceDirName":".","slug":"/Optimisation","permalink":"/gomoku/docs/Optimisation","draft":false,"unlisted":false,"editUrl":"https://github.com/yanisdolivet/gomoku/tree/main/documentation/docs/Optimisation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"Optimisation","title":"Optimisation","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Ai","permalink":"/gomoku/docs/Ai"},"next":{"title":"Ci-cd","permalink":"/gomoku/docs/Ci-cd"}}');var o=t(4848),s=t(8453);const a={id:"Optimisation",title:"Optimisation",sidebar_position:3},r="Optimisation",l={},c=[{value:"Bitset",id:"bitset",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2},{value:"Loading binary file for loading model",id:"loading-binary-file-for-loading-model",level:2},{value:"Loop Unrolling",id:"loop-unrolling",level:2},{value:"Brut pointer",id:"brut-pointer",level:2},{value:"Branchless code (without if condition)",id:"branchless-code-without-if-condition",level:2},{value:"Pre allocated buffer",id:"pre-allocated-buffer",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"optimisation",children:"Optimisation"})}),"\n",(0,o.jsx)(i.h2,{id:"bitset",children:"Bitset"}),"\n",(0,o.jsx)(i.p,{children:"To optimise the project, we use bitset to store the board state and avoid using vectors or 2D arrays.\nThe reason is that vectors and 2D arrays are not optimised for the minimax algorithm and can lead to performance issues.\nA bitset uses only 1 bit per position, whereas a vector or 2D array of int uses 32 bits (4 bytes) per position. This makes a bitset 32 times more space-efficient, which is why we use it in the Board class."}),"\n",(0,o.jsx)(i.h2,{id:"bitwise-operations",children:"Bitwise operations"}),"\n",(0,o.jsx)(i.p,{children:"To optimise the project, we use bitwise operations to check for a winner. We need to optimise this function because it is call by the Monte Carlo Tree Search algorithm. Monte Carlo Tree Search search for the best move by simulating multiple games. If checkWin take only 10ms to check the winner, the Monte Carlo Tree Search can simulate 1 000 000 games in 1 second. If checkWin take 1 millisecond to check the winner, the Monte Carlo Tree Search can simulate 1 000 games in 1 second.\nBitwise operations are faster than using loops to check for a winner because they are executed at the hardware level.\nTo explain it simply, bitwise operations are executed at the hardware level, while loops are executed at the software level. To check winner with loop, we need to check each bit of the board, while with bitwise operations, we can check multiple bits at once. At the final, bitwise check 64 bits (because processor is 64 bits) in 1 operation, while loop check 1 bit in 1 operation. The processor execute only 7 operations to check for a winner with bitwise.\nBitwise is the ultimate optimisation for this project for 3 reasons:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"No loop on runtime, all the loop are implemented in the hardware level"}),"\n",(0,o.jsx)(i.li,{children:"Register parallelism, the processor can execute multiple operations at once"}),"\n",(0,o.jsx)(i.li,{children:"Branchless, no if condition to check for a winner. This condition is not optimised by the processor. The instruction flux is linear, this is perfect for the processor."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"To add more optimisation on the bitwise operations, we use inline function. That reduce the function call overhead and improve the performance. In a optimised code function call makes loose many performance. That would be shameful for a project like this."}),"\n",(0,o.jsx)(i.h2,{id:"loading-binary-file-for-loading-model",children:"Loading binary file for loading model"}),"\n",(0,o.jsx)(i.p,{children:"Loading model files as binary data is crucial for performance. Instead of parsing text-based formats, which can be slow and resource-intensive, we directly read the raw binary data representing the model's weights and biases. This allows for much faster loading times, which is especially important for applications requiring quick initialization or frequent model updates."}),"\n",(0,o.jsxs)(i.p,{children:["The following C++ lambda function ",(0,o.jsx)(i.code,{children:"loadTensor"})," is used to efficiently load a ",(0,o.jsx)(i.code,{children:"Tensor"})," object from a binary file:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cpp",children:"auto loadTensor = [&](Tensor &tensor) {\n    file.read(reinterpret_cast<char*>(tensor.values.data()),\n              tensor.size() * sizeof(float));\n};\n"})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Explanation:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"auto loadTensor = [&](Tensor &tensor)"})}),": This defines a lambda function named ",(0,o.jsx)(i.code,{children:"loadTensor"}),".","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"auto"}),": The compiler deduces the type of ",(0,o.jsx)(i.code,{children:"loadTensor"}),"."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"[&]"}),": This captures all external variables by reference within the lambda's scope. In this case, it likely captures ",(0,o.jsx)(i.code,{children:"file"}),", which is an ",(0,o.jsx)(i.code,{children:"ifstream"})," or similar file stream object."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"(Tensor &tensor)"}),": The lambda takes a reference to a ",(0,o.jsx)(i.code,{children:"Tensor"})," object as an argument. This ",(0,o.jsx)(i.code,{children:"Tensor"})," is where the loaded data will be stored."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"file.read(...)"})}),": This is a method typically found in C++ ",(0,o.jsx)(i.code,{children:"fstream"})," objects (like ",(0,o.jsx)(i.code,{children:"ifstream"}),"). It reads a block of raw binary data from the file.","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"reinterpret_cast<char*>(tensor.values.data())"})}),":","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"tensor.values.data()"}),": Assumes ",(0,o.jsx)(i.code,{children:"tensor.values"})," is some form of container (e.g., ",(0,o.jsx)(i.code,{children:"std::vector<float>"}),") that stores the tensor's data. The ",(0,o.jsx)(i.code,{children:".data()"})," method returns a pointer to the underlying array where the ",(0,o.jsx)(i.code,{children:"float"})," values are stored."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"reinterpret_cast<char*>"}),": The ",(0,o.jsx)(i.code,{children:"file.read()"})," method expects a ",(0,o.jsx)(i.code,{children:"char*"})," pointer to the buffer where the data should be read. Since ",(0,o.jsx)(i.code,{children:"tensor.values.data()"})," returns a pointer to ",(0,o.jsx)(i.code,{children:"float"})," (or similar), it's reinterpreted as a ",(0,o.jsx)(i.code,{children:"char*"})," to allow the raw byte-level read operation. This is safe as long as the memory pointed to is valid and the size matches."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"tensor.size() * sizeof(float)"})}),": This calculates the total number of bytes to read.","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"tensor.size()"}),": Returns the total number of elements (e.g., ",(0,o.jsx)(i.code,{children:"float"}),"s) in the tensor."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"sizeof(float)"}),": Returns the size in bytes of a single ",(0,o.jsx)(i.code,{children:"float"})," data type (typically 4 bytes)."]}),"\n",(0,o.jsx)(i.li,{children:"Multiplying these two gives the total byte size of the data to be read for the entire tensor."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["In essence, this ",(0,o.jsx)(i.code,{children:"loadTensor"})," lambda reads the exact byte representation of the ",(0,o.jsx)(i.code,{children:"Tensor"}),"'s floating-point values directly from the binary file into the ",(0,o.jsx)(i.code,{children:"tensor.values"})," buffer, making the model loading process very efficient."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.strong,{children:"Reasons"}),"\nThis method is the most efficient way to load a tensor from a binary file because it allows us to read the raw bytes of the data stored in the file. This is much faster than parsing the data as text, which can be slow and resource-intensive. In addition, it consummes less memory than parsing the data as text, which can be a problem when loading large models.\nFinally, it consumes less cpu resource because it doesn't need loop to parse the data."]}),"\n",(0,o.jsx)(i.h2,{id:"loop-unrolling",children:"Loop Unrolling"}),"\n",(0,o.jsx)(i.p,{children:"To optimize the dense layer, we use loop unrolling. To explain it simply, loop unrolling is a technique that allows us to execute multiple iterations of a loop in a single instruction. This is much faster than executing a loop in a single instruction."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cpp",children:"for (int n = 0; n < inputSize - 4; n += 4) {\n    sum += inputData[n] * weightData[n * outputSize + neuron];\n    sum += inputData[n + 1] * weightData[(n + 1) * outputSize + neuron];\n    sum += inputData[n + 2] * weightData[(n + 2) * outputSize + neuron];\n    sum += inputData[n + 3] * weightData[(n + 3) * outputSize + neuron];\n}\n"})}),"\n",(0,o.jsx)(i.p,{children:"In this loop, we execute 4 iterations of the loop in a single instruction. This is much faster than executing a loop in a single instruction."}),"\n",(0,o.jsx)(i.h2,{id:"brut-pointer",children:"Brut pointer"}),"\n",(0,o.jsx)(i.p,{children:"In the dense layer, we use brut pointer to access the data. This is much faster than using an iterator."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cpp",children:"const float *inputData = input.values.data();\nconst float *weightData = weight.values.data();\n"})}),"\n",(0,o.jsx)(i.h2,{id:"branchless-code-without-if-condition",children:"Branchless code (without if condition)"}),"\n",(0,o.jsx)(i.p,{children:"Use branchless code to avoid if condition in predict method. This is much faster than using if condition."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-cpp",children:"for (int n = 0; n < 400; ++n) {\ninputData[n] = (float)myBoard.test(n) - (float)opponentBoard.test(n);\n}\n"})}),"\n",(0,o.jsx)(i.h2,{id:"pre-allocated-buffer",children:"Pre allocated buffer"}),"\n",(0,o.jsx)(i.p,{children:"In the dense layer, we use pre allocated buffer to store the data. This is much faster than using a vector."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>r});var n=t(6540);const o={},s=n.createContext(o);function a(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);